{"version":3,"file":"rimaxState.min.js","sources":["../hooks/useState.js","../hooks/useRef.js","../hooks/useEvent.js","../hooks/useEffect.js","../hooks/useLayoutEffect.js","../hooks/useProps.js","../hooks/useMemo.js"],"sourcesContent":["const guardFn = v => v\r\nconst stateSymbol = Symbol(\"$$State\")\r\nconst isState = ((ref) => (typeof ref == \"object\") && stateSymbol === ref[\".rxType\"]).bind()\r\nexport class RXState {\r\n    get isArray() { return Array.isArray(this.value) }\r\n    toString() { return String(this.value) }\r\n    valueOf() { return this.value }\r\n    get [\".rxType\"]() { return stateSymbol }\r\n    static isState = isState\r\n}\r\nfunction createState(value, guard) {\r\n    let currentValueOfState\r\n    let oldValueOfState\r\n    let isDestroyed = false\r\n    let subscriber=0\r\n    const ID = Math.random()\r\n    const GUARDS = []\r\n    const DESTROY_EVENTS = new Set()\r\n    const UPDATE_EVENTS = new Set()\r\n    const ACTIONS={}\r\n    const dispatchUpdate = (option) => { UPDATE_EVENTS.forEach(fn =>fn(currentValueOfState, oldValueOfState, option)) }\r\n    \r\n    return Object.freeze(new (class rxState extends RXState {\r\n        get guards() { return [...GUARDS] }\r\n        get isDestroyed() { return isDestroyed }\r\n        get id() { return ID }\r\n        get len() { return {onChange:UPDATE_EVENTS.size,onCleanup:DESTROY_EVENTS.size,subscriber} }\r\n        addGuard(guard) {\r\n            if (!(guard instanceof Function)) return () => undefined\r\n            const callback = (...a) => guard(...a)\r\n            const lastIndex = GUARDS.push(callback) - 1\r\n            let isRemoved = false\r\n            return () => {\r\n                if (isRemoved) return true\r\n                if (GUARDS[lastIndex] === callback) {\r\n                    GUARDS.splice(lastIndex, 1)\r\n                    isRemoved = true\r\n                    return true\r\n                }\r\n                const i = GUARDS.find(fn => fn === callback)\r\n                if (i > -1) {\r\n                    GUARDS.splice(i, 1)\r\n                    return true\r\n                }\r\n                return false\r\n            }\r\n        }\r\n\r\n        clear(withDom = false) {\r\n            DESTROY_EVENTS.forEach(fn => fn(withDom))\r\n            DESTROY_EVENTS.clear()\r\n            UPDATE_EVENTS.clear()\r\n        }\r\n        destroy(withDom = true) {\r\n            if (isDestroyed) return;\r\n            this.clear(withDom)\r\n            isDestroyed = true\r\n        }\r\n\r\n        onChange = ((callbackOrState, directApply = false) => {\r\n            if (callbackOrState instanceof RXState) {\r\n                const callback = directApply instanceof Function ? directApply : v => v\r\n                const state=callbackOrState\r\n                subscriber++\r\n                let isRemoved\r\n                return this.onChange((...args) =>{\r\n                    state.set(() => callback(...args), ...args.slice(1))\r\n                    return ()=>{\r\n                        if(isRemoved) return\r\n                        isRemoved=true\r\n                        subscriber--\r\n                    }\r\n                }, true)\r\n            }\r\n            if (!(callbackOrState instanceof Function)) throw new Error(\"callback doit être une fonction\")\r\n            const on = {\r\n                dispatch: callbackOrState, destroy: directApply ? callbackOrState(this.value, undefined, { methode: \"set\", value: this.value }) : undefined\r\n            }\r\n            const onDispatch = (...arg) => on.destroy = on.dispatch(...arg)\r\n            let isCalled = false\r\n            const destroy = (...arg) => {\r\n                if (isCalled) return\r\n                isCalled = true\r\n                if (on.destroy instanceof Function) on.destroy(...arg);\r\n                DESTROY_EVENTS.delete(destroy)\r\n                UPDATE_EVENTS.delete(onDispatch)\r\n            }\r\n            UPDATE_EVENTS.add(onDispatch)\r\n            DESTROY_EVENTS.add(destroy)\r\n            return destroy\r\n        }).bind()\r\n        onCleanup = ((callback) => {\r\n            if (!(callback instanceof Function)) throw new Error(\"callback doit être une fonction\")\r\n            const fn=(...args)=>callback(...args)\r\n            DESTROY_EVENTS.add(fn)\r\n            return () => DESTROY_EVENTS.delete(callback)\r\n        }).bind()\r\n\r\n\r\n        get oldValue() { return oldValueOfState }\r\n\r\n        constructor(value, guard = v => v) {\r\n            super()\r\n            Object.defineProperty(this, \"value\", {\r\n                get: (() => currentValueOfState).bind(),\r\n                set: ((value) => this.set(value)).bind(),\r\n                enumerable: true,\r\n            })\r\n            if(guard&& typeof guard ==\"object\"){\r\n                Object.assign(ACTIONS,guard.actions??{})\r\n                guard=guard.guard??(v => v)\r\n            }\r\n            if (!(guard instanceof Function)) throw new Error(\"guard doit être une fonction\")\r\n            currentValueOfState = value\r\n            GUARDS.push(guard)\r\n            const toValidate = (value, oldValue = oldValueOfState, option = {}) => {\r\n                const oldValues = []\r\n                return GUARDS.reduceRight((val, guardFn) => {\r\n                    oldValues.push(val)\r\n                    return guardFn(val, oldValue, option, [...oldValues])\r\n                }, value)\r\n            }\r\n            if (!(value instanceof Promise)) {\r\n                currentValueOfState = toValidate(value, undefined, {})\r\n            }\r\n            const createStateComputed = (callback = () => currentValueOfState, dependencies = [], guard = v => v) => {\r\n                if (!(callback instanceof Function)) throw new Error(\"callback doit être une function\")\r\n                if (isDestroyed) throw new Error(\"cette Etat ne peut plus etre utiliser car elle est deja detruit\")\r\n                const optDependencies=(dependencies&&!Array.isArray(dependencies)&&typeof dependencies==\"object\")?dependencies:{}\r\n                dependencies=Array.isArray(dependencies)?dependencies:optDependencies.dependencies??[]\r\n                if (!Array.isArray(dependencies)) throw new Error(\"dependencies doit être une Array\")\r\n                const update = (option = {}) => callback(currentValueOfState, oldValueOfState, option)\r\n                const optionState={guard,...optDependencies}\r\n                const [state, setState] = useState(update(), optionState)\r\n                if(optionState.guard!==guard)state.addGuard(guard);\r\n                const states = [this, ...dependencies]\r\n                const listrmv = states.map(st => {\r\n                    if (st instanceof RXState) {\r\n                        return st.onChange((_1, _2, option) => {\r\n                            setState(update(option), option)\r\n                            return () => !state.isDestroyed && state.destroy(true)\r\n                        })\r\n                    }\r\n                })\r\n                state.onCleanup(() => listrmv.map(fn => fn instanceof Function && fn()))\r\n                return state\r\n            }\r\n            this.get = ((callback = () => this.value, dependencies = []) => createStateComputed(callback, dependencies)).bind()\r\n            Object.entries(stateType).map(([type, fnGuard]) => this.get[type] = (callback = () => this.value, dependencies = []) => createStateComputed(callback, dependencies, fnGuard))\r\n            this.set = ((value, option = { methode: \"set\", value: value }) => {\r\n                if (isDestroyed) throw new Error(\"cette Etat ne peut plus etre utiliser car elle est deja detruit\")\r\n                if (typeof option != \"object\") throw new Error(\"option doit être un object\")\r\n                if (value instanceof Promise) {\r\n                    return value.then(v => this.set(v))\r\n                }\r\n                if (value instanceof RXState) value = value.value;\r\n                if (value instanceof Function) value = value(currentValueOfState, oldValueOfState)\r\n                const _oldValue = currentValueOfState\r\n                if (_oldValue !== value) {\r\n                    value = toValidate(value, _oldValue, option);\r\n                    oldValueOfState = _oldValue\r\n                    currentValueOfState = value\r\n                    dispatchUpdate(option)\r\n                }\r\n                return currentValueOfState\r\n            }).bind()\r\n            insertArrayMethode(this, { createStateComputed })\r\n            Object.entries(ACTIONS).map(([k,v])=>this.set[k]=payload=>this.set(v instanceof Function ?v(currentValueOfState,payload):v))\r\n            if (value instanceof Promise) {\r\n                value.then(v => this.set(v))\r\n            }\r\n        }\r\n\r\n    })(value, guard))\r\n}\r\nconst stateType = {\r\n    array(v) {\r\n        if (!Array.isArray(v)) throw new Error(\"cette state doit être de type Array\")\r\n        return v\r\n    },\r\n    number(v) {\r\n        if (typeof v != \"number\") throw new Error(\"cette state doit être de type Number\")\r\n        return v\r\n    },\r\n    string(v) {\r\n        if (typeof v != \"string\") throw new Error(\"cette state doit être de type string\")\r\n        return v\r\n    },\r\n    function(v) {\r\n        if (typeof v != \"function\") throw new Error(\"cette state doit être de type function\")\r\n        return v\r\n    },\r\n    boolean(v) {\r\n        if (typeof v != \"boolean\") throw new Error(\"cette state doit être de type boolean\")\r\n        return v\r\n    },\r\n    symbol(v) {\r\n        if (typeof v != \"symbol\") throw new Error(\"cette state doit être de type symbol\")\r\n        return v\r\n    },\r\n    object(v) {\r\n        if (typeof v != \"object\") throw new Error(\"cette state doit être de type object\")\r\n        return v\r\n    },\r\n}\r\nfunction insertArrayMethode(stateInstace, { createStateComputed }) {\r\n    const state = stateInstace\r\n    const isArray = () => {\r\n        if (!state.isArray) throw new Error(\"pour pouvoir utiliser cette methode le type de state doit être une Array\")\r\n    }\r\n    const isFunction = (callback) => {\r\n        if (!(callback instanceof Function)) throw new Error(\"callback doit doit être une function\")\r\n    }\r\n    const getIndex = (index) => {\r\n        if (index instanceof RXState) {\r\n            index = index.value\r\n        }\r\n        if (index instanceof Function) {\r\n            index = state.value.findIndex(index)\r\n        }\r\n        if (isNaN(index)) throw new Error(\"index doit être une nombre ou une fonction qui retourne un nombre\")\r\n        return index\r\n    }\r\n    state.get.map = (callback) => {\r\n        isFunction(callback)\r\n        const createState = (v, i) => [useState(v)[0], useState(i)[0]]\r\n        const rendMap = (v) => callback(...v, state)\r\n        const listState = state.value.map(createState)\r\n        let listElement = listState.map(rendMap)\r\n        const [items, setItems] = useState(listElement)\r\n        const update = () => listState.map(([v, i], index) => {\r\n            if (!i.isDestroyed) i.set(index);\r\n            if (!v.isDestroyed) v.set(state.value[index]);\r\n        })\r\n        state.onChange((val) => {\r\n            if (listState.length > val.length) {\r\n                const indexStart = val.length\r\n                const end = listState.length\r\n                listState.splice(indexStart, end).map(s => s.map(i => i.destroy(true)))\r\n                setItems.splice(indexStart, end)\r\n            } else if (listState.length < val.length) {\r\n                const indexStart = listState.length\r\n                listState.push(...val.slice(indexStart).map(createState))\r\n                listState.map(([, index], i) => index.set(i))\r\n                setItems.push(...listState.slice(indexStart).map(rendMap))\r\n            }\r\n            update()\r\n            // console.log(items.value);\r\n        })\r\n        return items\r\n    }\r\n    state.get.callback = (callback) => {\r\n        if (!(callback instanceof Function)) throw new Error(\"callback doit être une function\")\r\n        return state.get(() => callback)\r\n    }\r\n    const action = (args, action) => {\r\n        isArray()\r\n        if (state.value[action] instanceof Function) {\r\n            const returnValue = state.value[action](...args)\r\n            return state.set([...state.value], { methode: \"set\", action, args, returnValue })\r\n        }\r\n    }\r\n    // TODO: state.set.remove\r\n    // TODO: state.set.removeItem\r\n    // TODO: state.set.editItem\r\n    state.set.splice = (...args) => action([...args], \"splice\")\r\n    state.set.remove = (start, deleteCount = 1) => {\r\n        const returnValue = state.value.splice(start, deleteCount)\r\n        return state.set([...state.value], { methode: \"set\", action: \"remove\", args: [start, deleteCount], returnValue })\r\n    }\r\n    state.set.edit = (index, value) => {\r\n        isArray()\r\n        index = getIndex(index)\r\n        if (index > -1) {\r\n            if (value instanceof Function) {\r\n                value = value(state.value[index], index, state.value)\r\n            }\r\n            const returnValue = state.value.splice(index, 1, value)\r\n            return state.set([...state.value], { methode: \"set\", action: \"edit\", args: [index, value], returnValue })\r\n        }\r\n    }\r\n    state.set.push = (...items) => action([...items], \"push\")\r\n    state.set.pop = () => action([], \"pop\")\r\n    state.set.shift = () => action([], \"shift\")\r\n    state.set.unshift = (...items) => action([...items], \"shift\")\r\n    state.set.reverse = () => action([], \"reverse\")\r\n    state.set.fill = (...items) => action([...items], \"fill\")\r\n    state.set.filter = (predicate, ...args) => {\r\n        isArray()\r\n        isFunction(predicate)\r\n        const returnValue = state.value.filter(predicate, ...args)\r\n        return state.set(returnValue, { methode: \"set\", action: \"filter\", args: [predicate, ...args], returnValue })\r\n    }\r\n    state.set.slice = (...args) => {\r\n        isArray()\r\n        const returnValue = state.value.slice(...args)\r\n        return state.set(returnValue, { methode: \"set\", action: \"slice\", args, returnValue })\r\n    }\r\n    state.set.sort = (compareFn = (a, b) => b - a) => {\r\n        isArray()\r\n        isFunction(compareFn)\r\n        const oldValue = state.value.slice()\r\n        const returnValue = state.value.sort(compareFn)\r\n        if (returnValue.every((item, index) => item === oldValue[index])) return state.value\r\n        return state.set(returnValue, { methode: \"set\", action: \"sort\", args:arguments, returnValue })\r\n    }\r\n    state.set.map = (callbackfn, thisArg = state.value) => {\r\n        isArray()\r\n        isFunction(callbackfn)\r\n        const returnValue = state.value.map(callbackfn, ...args)\r\n        return state.set(returnValue, { methode: \"set\", action: \"map\", args, returnValue })\r\n    }\r\n}\r\n\r\nexport default function useState(value, guard = guardFn) {\r\n    if (value instanceof RXState) {\r\n        value = value\r\n        if (guard instanceof Function && guard !== guardFn) value.addGuard(guard);\r\n    } else if (Array.isArray(value) && value[0] instanceof RXState && value[1] === value[0].set) {\r\n        value = value[0]\r\n        if (guard instanceof Function && guard !== guardFn) value.addGuard(guard);\r\n    } else {\r\n        value = createState(value, guard)\r\n    }\r\n    return [value, value.set]\r\n}\r\n\r\n\r\nObject.entries(stateType).map(([type, guard]) => useState[type] = (value) => useState(value, guard))\r\nuseState.isState = isState","import useState from \"./useState.js\"\r\nconst refSymbol=Symbol(\"$$ref\")\r\nexport default function useRef(value) {\r\n    const [ref, changeRef] = useState(value)\r\n    const OBJECT=Object\r\n    return OBJECT.freeze(new (class Object {\r\n        constructor(){\r\n            OBJECT.defineProperty(this,\"current\",{\r\n                get:(()=>ref.value).bind(),\r\n                set:((val)=>changeRef(val)).bind(),\r\n                enumerable:true,\r\n                configurable:false\r\n            })\r\n            OBJECT.defineProperty(this,\"onChange\",{\r\n                value:((fn)=>ref.onChange(fn)).bind(),\r\n                enumerable:true,\r\n            })\r\n        }\r\n        onCleanup(fn){return ref.onCleanup(fn)}\r\n        destroy(fn){return ref.destroy(true)}\r\n        set(fn){return changeRef(fn)}\r\n        get [\".rxType\"](){return refSymbol}\r\n    }))\r\n}\r\nuseRef.isRef=((ref)=>(typeof ref==\"object\")&&refSymbol===ref[\".rxType\"]).bind()\r\n","const handlerEvent = {\r\n    beforeDispatch: (...args) => [...args],\r\n    afterDispatch: (data, returnValue) => [data, returnValue],\r\n    onSubscribe: callback => callback,\r\n    clearAfterEachDispatch:false\r\n}\r\nexport function useEvent(handler = handlerEvent) {\r\n    if (typeof handler !== \"object\") throw new Error(\"handler doit être un object\")\r\n    const { beforeDispatch=handlerEvent.beforeDispatch, afterDispatch=handlerEvent.afterDispatch, onSubscribe=handlerEvent.onSubscribe,clearAfterEachDispatch=handlerEvent.clearAfterEachDispatch} = handler\r\n    const EVENTS = new Set()\r\n    const subscribe = (callback) => {\r\n        if (!(callback instanceof Function)) throw new Error(\"callback doit être un function\")\r\n        callback = onSubscribe(callback)\r\n        if (callback instanceof Function) EVENTS.add(callback)\r\n        return () => EVENTS.delete(callback)\r\n    }\r\n    return [subscribe, (data,...rest) => {\r\n        const args = beforeDispatch(data,...rest)\r\n        const returnValue = EVENTS.forEach(fn => fn?.(...(Array.isArray(args)?args:[args])))\r\n        if(clearAfterEachDispatch)EVENTS.clear();\r\n        return afterDispatch(data, returnValue)\r\n    }]\r\n}","import { RXState } from \"./useState.js\"\r\n\r\nexport function useEffect(callback, states = []) {\r\n    if (!Array.isArray(states)) throw new Error(\"states doit être une Array\")\r\n    const listRmv = []\r\n    let remove\r\n    const array = [...states]\r\n    const getValue = s => s instanceof RXState ? s.value : s\r\n    const update=i=> Promise.resolve().then(() => remove = callback([...array.map(getValue)],i))\r\n    array.forEach((st, i) => {\r\n        if (st instanceof RXState) {\r\n            listRmv.push(st.onChange(() => {update(i)}))\r\n        }\r\n    })\r\n    requestIdleCallback(() => remove = callback([...array.map(getValue)],-1))\r\n    return () => {\r\n        listRmv.splice(0,listRmv.length).map(fn => fn?.())\r\n        if (remove instanceof Function) remove(-1, [...array].map(getValue))\r\n    }\r\n}","import { RXState } from \"./useState.js\"\r\n\r\nexport function useLayoutEffect(callback, states = []) {\r\n    if (!Array.isArray(states)) throw new Error(\"states doit être une Array\")\r\n    const listRmv = []\r\n    let remove\r\n    const array = [...states]\r\n    const getValue = s => s instanceof RXState ? s.value : s\r\n    const update=i=> remove = callback([...array.map(getValue)],i)\r\n    array.forEach((st, i) => {\r\n        if (st instanceof RXState) {\r\n            listRmv.push(st.onChange(() => {update(i)}))\r\n        }\r\n    })\r\n    update(-1)\r\n    return () => {\r\n        listRmv.splice(0,listRmv.length).map(fn => fn?.())\r\n        if (remove instanceof Function) remove(-1, [...array].map(getValue))\r\n    }\r\n}","import useState from \"./useState.js\";\r\n\r\nexport function useProps(props = {}) {\r\n    if(typeof props !=\"object\") throw new Error(\"props doit être une object\")\r\n    return {\r\n        ...Object.entries(props).reduce((prop, [key, value]) => ({ ...prop, [key]: (key === \"children\" || key.startsWith(\"$\"))? value :useState.isState(value) ?value : useState(value)[0] }), {})\r\n    }\r\n}","import useState, { RXState } from \"./useState.js\"\r\n\r\nexport function useMemo(callback, states = []) {\r\n    if (!Array.isArray(states)) throw new Error(\"states doit être une Array\")\r\n    const listRmv = []\r\n    const [state,setState]=useState()\r\n    const array = [...states]\r\n    const getValue = s => s instanceof RXState ? s.value : s\r\n    const update=i=> setState(callback([...array.map(getValue)],i))\r\n    array.forEach((st, i) => {\r\n        if (st instanceof RXState) {\r\n            listRmv.push(st.onChange(() => {update(i)}))\r\n        }\r\n    })\r\n    update(-1)\r\n    state.onCleanup(()=>listRmv.splice(0,listRmv.length).map(fn => fn?.()))\r\n    return state\r\n}"],"names":["guardFn","v","stateSymbol","Symbol","isState","ref","bind","RXState","isArray","Array","this","value","toString","String","valueOf","static","createState","guard","currentValueOfState","oldValueOfState","isDestroyed","subscriber","ID","Math","random","GUARDS","DESTROY_EVENTS","Set","UPDATE_EVENTS","ACTIONS","Object","freeze","guards","id","len","onChange","size","onCleanup","addGuard","Function","callback","a","lastIndex","push","isRemoved","splice","i","find","fn","clear","withDom","forEach","destroy","callbackOrState","directApply","state","args","set","slice","Error","on","dispatch","undefined","methode","onDispatch","arg","isCalled","delete","add","oldValue","constructor","super","defineProperty","get","enumerable","assign","actions","toValidate","option","oldValues","reduceRight","val","Promise","createStateComputed","dependencies","optDependencies","update","optionState","setState","useState","listrmv","map","st","_1","_2","entries","stateType","type","fnGuard","then","_oldValue","dispatchUpdate","stateInstace","isFunction","getIndex","index","findIndex","isNaN","rendMap","listState","listElement","items","setItems","length","indexStart","end","s","action","returnValue","remove","start","deleteCount","edit","pop","shift","unshift","reverse","fill","filter","predicate","sort","compareFn","b","every","item","arguments","callbackfn","thisArg","insertArrayMethode","k","payload","array","number","string","function","boolean","symbol","object","refSymbol","useRef","changeRef","OBJECT","configurable","isRef","handlerEvent","beforeDispatch","afterDispatch","data","onSubscribe","clearAfterEachDispatch","states","listRmv","getValue","resolve","requestIdleCallback","props","reduce","prop","key","startsWith","handler","EVENTS","rest"],"mappings":"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"}