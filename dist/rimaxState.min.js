const e=e=>e,t=Symbol("$$State"),r=(e=>"object"==typeof e&&t===e[".rxType"]).bind();class n{get isArray(){return Array.isArray(this.value)}toString(){return String(this.value)}valueOf(){return this.value}get".rxType"(){return t}static isState=r}function o(e,t){let r,o,a=!1,c=0;const u=Math.random(),l=[],f=new Set,d=new Set,h={};return Object.freeze(new class extends n{get guards(){return[...l]}get isDestroyed(){return a}get id(){return u}get len(){return{onChange:d.size,onCleanup:f.size,subscriber:c}}addGuard(e){if(!(e instanceof Function))return()=>{};const t=(...t)=>e(...t),r=l.push(t)-1;let n=!1;return()=>{if(n)return!0;if(l[r]===t)return l.splice(r,1),n=!0,!0;const e=l.find((e=>e===t));return e>-1&&(l.splice(e,1),!0)}}clear(e=!1){f.forEach((t=>t(e))),f.clear(),d.clear()}destroy(e=!0){a||(this.clear(e),a=!0)}onChange=((e,t=!1)=>{if(e instanceof n){const r=t instanceof Function?t:e=>e,n=e;let o;return c++,this.onChange(((...e)=>(n.set((()=>r(...e)),...e.slice(1)),()=>{o||(o=!0,c--)})),!0)}if(!(e instanceof Function))throw new Error("callback doit être une fonction");const r={dispatch:e,destroy:t?e(this.value,void 0,{methode:"set",value:this.value}):void 0},o=(...e)=>r.destroy=r.dispatch(...e);let s=!1;const i=(...e)=>{s||(s=!0,r.destroy instanceof Function&&r.destroy(...e),f.delete(i),d.delete(o))};return d.add(o),f.add(i),i}).bind();onCleanup=(e=>{if(!(e instanceof Function))throw new Error("callback doit être une fonction");return f.add(((...t)=>e(...t))),()=>f.delete(e)}).bind();get oldValue(){return o}constructor(e,t=(e=>e)){if(super(),Object.defineProperty(this,"value",{get:(()=>r).bind(),set:(e=>this.set(e)).bind(),enumerable:!0}),t&&"object"==typeof t&&(Object.assign(h,t.actions??{}),t=t.guard??(e=>e)),!(t instanceof Function))throw new Error("guard doit être une fonction");r=e,l.push(t);const c=(e,t=o,r={})=>{const n=[];return l.reduceRight(((e,o)=>(n.push(e),o(e,t,r,[...n]))),e)};e instanceof Promise||(r=c(e,void 0,{}));const u=(e=(()=>r),t=[],s=(e=>e))=>{if(!(e instanceof Function))throw new Error("callback doit être une function");if(a)throw new Error("cette Etat ne peut plus etre utiliser car elle est deja detruit");const c=t&&!Array.isArray(t)&&"object"==typeof t?t:{};if(t=Array.isArray(t)?t:c.dependencies??[],!Array.isArray(t))throw new Error("dependencies doit être une Array");const u=(t={})=>e(r,o,t),l={guard:s,...c},[f,d]=i(u(),l);l.guard!==s&&f.addGuard(s);const h=[this,...t].map((e=>{if(e instanceof n)return e.onChange(((e,t,r)=>(d(u(r),r),()=>!f.isDestroyed&&f.destroy(!0))))}));return f.onCleanup((()=>h.map((e=>e instanceof Function&&e())))),f};this.get=((e=(()=>this.value),t=[])=>u(e,t)).bind(),Object.entries(s).map((([e,t])=>this.get[e]=(e=(()=>this.value),r=[])=>u(e,r,t))),this.set=((e,t={methode:"set",value:e})=>{if(a)throw new Error("cette Etat ne peut plus etre utiliser car elle est deja detruit");if("object"!=typeof t)throw new Error("option doit être un object");if(e instanceof Promise)return e.then((e=>this.set(e)));e instanceof n&&(e=e.value),e instanceof Function&&(e=e(r,o));const s=r;return s!==e&&(e=c(e,s,t),o=s,r=e,(e=>{d.forEach((t=>t(r,o,e)))})(t)),r}).bind(),function(e,{createStateComputed:t}){const r=e,o=()=>{if(!r.isArray)throw new Error("pour pouvoir utiliser cette methode le type de state doit être une Array")},s=e=>{if(!(e instanceof Function))throw new Error("callback doit doit être une function")},a=e=>{if(e instanceof n&&(e=e.value),e instanceof Function&&(e=r.value.findIndex(e)),isNaN(e))throw new Error("index doit être une nombre ou une fonction qui retourne un nombre");return e};r.get.map=e=>{s(e);const t=(e,t)=>[i(e)[0],i(t)[0]],n=t=>e(...t,r),o=r.value.map(t);let a=o.map(n);const[c,u]=i(a),l=()=>o.map((([e,t],n)=>{t.isDestroyed||t.set(n),e.isDestroyed||e.set(r.value[n])}));return r.onChange((e=>{if(o.length>e.length){const t=e.length,r=o.length;o.splice(t,r).map((e=>e.map((e=>e.destroy(!0))))),u.splice(t,r)}else if(o.length<e.length){const r=o.length;o.push(...e.slice(r).map(t)),o.map((([,e],t)=>e.set(t))),u.push(...o.slice(r).map(n))}l()})),c},r.get.callback=e=>{if(!(e instanceof Function))throw new Error("callback doit être une function");return r.get((()=>e))};const c=(e,t)=>{if(o(),r.value[t]instanceof Function){const n=r.value[t](...e);return r.set([...r.value],{methode:"set",action:t,args:e,returnValue:n})}};r.set.splice=(...e)=>c([...e],"splice"),r.set.remove=(e,t=1)=>{const n=r.value.splice(e,t);return r.set([...r.value],{methode:"set",action:"remove",args:[e,t],returnValue:n})},r.set.edit=(e,t)=>{if(o(),(e=a(e))>-1){t instanceof Function&&(t=t(r.value[e],e,r.value));const n=r.value.splice(e,1,t);return r.set([...r.value],{methode:"set",action:"edit",args:[e,t],returnValue:n})}},r.set.push=(...e)=>c([...e],"push"),r.set.pop=()=>c([],"pop"),r.set.shift=()=>c([],"shift"),r.set.unshift=(...e)=>c([...e],"shift"),r.set.reverse=()=>c([],"reverse"),r.set.fill=(...e)=>c([...e],"fill"),r.set.filter=(e,...t)=>{o(),s(e);const n=r.value.filter(e,...t);return r.set(n,{methode:"set",action:"filter",args:[e,...t],returnValue:n})},r.set.slice=(...e)=>{o();const t=r.value.slice(...e);return r.set(t,{methode:"set",action:"slice",args:e,returnValue:t})},r.set.sort=(e=((e,t)=>t-e))=>{o(),s(e);const t=r.value.slice(),n=r.value.sort(e);return n.every(((e,r)=>e===t[r]))?r.value:r.set(n,{methode:"set",action:"sort",args:arguments,returnValue:n})},r.set.map=(e,t=r.value)=>{o(),s(e);const n=r.value.map(e,...args);return r.set(n,{methode:"set",action:"map",args:args,returnValue:n})}}(this,{createStateComputed:u}),Object.entries(h).map((([e,t])=>this.set[e]=e=>this.set(t instanceof Function?t(r,e):t))),e instanceof Promise&&e.then((e=>this.set(e)))}}(e,t))}const s={array(e){if(!Array.isArray(e))throw new Error("cette state doit être de type Array");return e},number(e){if("number"!=typeof e)throw new Error("cette state doit être de type Number");return e},string(e){if("string"!=typeof e)throw new Error("cette state doit être de type string");return e},function(e){if("function"!=typeof e)throw new Error("cette state doit être de type function");return e},boolean(e){if("boolean"!=typeof e)throw new Error("cette state doit être de type boolean");return e},symbol(e){if("symbol"!=typeof e)throw new Error("cette state doit être de type symbol");return e},object(e){if("object"!=typeof e)throw new Error("cette state doit être de type object");return e}};function i(t,r=e){return t instanceof n?r instanceof Function&&r!==e&&t.addGuard(r):Array.isArray(t)&&t[0]instanceof n&&t[1]===t[0].set?(t=t[0],r instanceof Function&&r!==e&&t.addGuard(r)):t=o(t,r),[t,t.set]}Object.entries(s).map((([e,t])=>i[e]=e=>i(e,t))),i.isState=r;const a=Symbol("$$ref");function c(e){const[t,r]=i(e),n=Object;return n.freeze(new class{constructor(){n.defineProperty(this,"current",{get:(()=>t.value).bind(),set:(e=>r(e)).bind(),enumerable:!0,configurable:!1}),n.defineProperty(this,"onChange",{value:(e=>t.onChange(e)).bind(),enumerable:!0})}onCleanup(e){return t.onCleanup(e)}destroy(e){return t.destroy(!0)}set(e){return r(e)}get".rxType"(){return a}})}c.isRef=(e=>"object"==typeof e&&a===e[".rxType"]).bind();const u={beforeDispatch:(...e)=>[...e],afterDispatch:(e,t)=>[e,t],onSubscribe:e=>e,clearAfterEachDispatch:!1};var l=Object.freeze({__proto__:null,useState:i,RXState:n,useRef:c,useEffect:function(e,t=[]){if(!Array.isArray(t))throw new Error("states doit être une Array");const r=[];let o;const s=[...t],i=e=>e instanceof n?e.value:e;return s.forEach(((t,a)=>{t instanceof n&&r.push(t.onChange((()=>{(t=>{Promise.resolve().then((()=>o=e([...s.map(i)],t)))})(a)})))})),requestIdleCallback((()=>o=e([...s.map(i)],-1))),()=>{r.splice(0,r.length).map((e=>e?.())),o instanceof Function&&o(-1,[...s].map(i))}},useLayoutEffect:function(e,t=[]){if(!Array.isArray(t))throw new Error("states doit être une Array");const r=[];let o;const s=[...t],i=e=>e instanceof n?e.value:e,a=t=>o=e([...s.map(i)],t);return s.forEach(((e,t)=>{e instanceof n&&r.push(e.onChange((()=>{a(t)})))})),a(-1),()=>{r.splice(0,r.length).map((e=>e?.())),o instanceof Function&&o(-1,[...s].map(i))}},useProps:function(e={}){if("object"!=typeof e)throw new Error("props doit être une object");return{...Object.entries(e).reduce(((e,[t,r])=>({...e,[t]:"children"===t||t.startsWith("$")||i.isState(r)?r:i(r)[0]})),{})}},useEvent:function(e=u){if("object"!=typeof e)throw new Error("handler doit être un object");const{beforeDispatch:t=u.beforeDispatch,afterDispatch:r=u.afterDispatch,onSubscribe:n=u.onSubscribe,clearAfterEachDispatch:o=u.clearAfterEachDispatch}=e,s=new Set;return[e=>{if(!(e instanceof Function))throw new Error("callback doit être un function");return(e=n(e))instanceof Function&&s.add(e),()=>s.delete(e)},(e,...n)=>{const i=t(e,...n),a=s.forEach((e=>e?.(...Array.isArray(i)?i:[i])));return o&&s.clear(),r(e,a)}]},useMemo:function(e,t=[]){if(!Array.isArray(t))throw new Error("states doit être une Array");const r=[],[o,s]=i(),a=[...t],c=e=>e instanceof n?e.value:e,u=t=>s(e([...a.map(c)],t));return a.forEach(((e,t)=>{e instanceof n&&r.push(e.onChange((()=>{u(t)})))})),u(-1),o.onCleanup((()=>r.splice(0,r.length).map((e=>e?.())))),o}});export{l as RimaxState};
//# sourceMappingURL=rimaxState.min.js.map
